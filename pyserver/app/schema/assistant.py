from pydantic import BaseModel, Field, validator
import uuid
from typing import List, Optional
from enum import Enum
from datetime import datetime


class BotType(str, Enum):
    chatbot = "chatbot"
    chat_retrieval = "chat_retrieval"
    agent = "agent"


class AgentType(str, Enum):
    gpt_3_5_turbo = "GPT 3.5 Turbo"
    gpt_4 = "GPT 4"
    gpt_4_azure_openai = "GPT 4 (Azure OpenAI)"


class Tools(str, Enum):
    ddg_search = "DDG Search"
    search_tavily = "Search (Tavily)"
    search_short_answer_tavily = "Search (short answer, Tavily)"
    retrieval = "Retrieval"
    arxiv = "Arxiv"
    pubmed = "PubMed"
    wikipedia = "Wikipedia"


class LLMType(str, Enum):
    gpt_3_5_turbo = "GPT 3.5 Turbo"
    gpt_4 = "GPT 4"
    gpt_4_azure_openai = "GPT 4 (Azure OpenAI)"


class Configurable(BaseModel):
    type: BotType = Field(default="agent", title="Bot Type", description="The type of bot.")
    agent_type: Optional[AgentType] = Field(default="GPT 3.5 Turbo", title="Agent Type", description="The type of agent, applicable if the bot type is 'agent'.")
    interrupt_before_action: Optional[bool] = Field(default=False, title="Tool Confirmation", description="If set to True, you'll be prompted to continue before each tool is executed. If False, tools will be executed automatically by the agent.")
    retrieval_description: Optional[str] = Field(default="Can be used to look up information that was uploaded for this assistant.", title="Retrieval Description", description="Tool description providing instructions to the LLM for it's use.")
    system_message: Optional[str] = Field(default="You are a helpful assistant.", title="Instructions", description="Instructions for the assistant.")
    tools: Optional[List[Tools]] = Field(default=[], title="Tools", description="List of tools available for the agent.")
    llm_type: Optional[LLMType] = Field(default="GPT 3.5 Turbo", title="LLM Type", description="The type of language model, applicable if the bot type is 'chat_retrieval' or 'chatbot'.")

class RunnableConfigurableAlternativesConfig(BaseModel):
    configurable: Configurable

class Assistant(BaseModel):
    id: uuid.UUID = Field(..., description="A unique identifier for the assistant. It's a UUID type and is automatically generated by the database.")
    user_id: Optional[str] = Field(..., description="The user id that created the assistant.")
    name: str = Field(..., description="The name of the assistant.", min_length=1)
    config: RunnableConfigurableAlternativesConfig = Field(..., description="The assistant config, containing specific configuration parameters.")
    public: bool = Field(..., description="Whether the assistant is public (i.e., customer-facing) or internal (i.e., used by staff or developers).")
    created_at: datetime = Field(..., description="Created date")
    updated_at: datetime = Field(..., description="Last updated date")

    class Config:
        from_attributes = True

class CreateAssistantSchema(BaseModel):
    name: str = Field(..., description="The name of the assistant.", min_length=1)
    user_id: Optional[str] = Field(None, description="The user id that created the assistant.")
    config: dict = Field(..., description="The assistant config, containing specific configuration parameters.")
    public: bool = Field(..., description="Whether the assistant is public (i.e., customer-facing) or internal (i.e., used by staff or developers).")

    @validator('name', 'config')
    def must_not_be_empty(cls, v):
        if not v:
            raise ValueError('name, config must not be empty')
        return v

class UpdateAssistantSchema(BaseModel):
    name: Optional[str] = Field(None, description="The name of the assistant.")
    config: Optional[dict] = Field(None, description="The assistant config, containing specific configuration parameters.")
    public: Optional[bool] = Field(None, description="Whether the assistant is public (i.e., customer-facing) or internal (i.e., used by staff or developers).")

